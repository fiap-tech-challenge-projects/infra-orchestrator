name: Deploy All Infrastructure

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - production
      skip_eks:
        description: 'Skip EKS cluster deployment (if already exists)'
        required: false
        type: boolean
        default: false
      skip_addons:
        description: 'Skip K8s Addons deployment (if already exists)'
        required: false
        type: boolean
        default: false
      skip_database:
        description: 'Skip Database deployment (if already exists)'
        required: false
        type: boolean
        default: false
      skip_lambda:
        description: 'Skip Lambda deployment'
        required: false
        type: boolean
        default: false
      skip_messaging:
        description: 'Skip Messaging deployment'
        required: false
        type: boolean
        default: false
      skip_app:
        description: 'Skip Microservices deployment'
        required: false
        type: boolean
        default: false

env:
  AWS_REGION: 'us-east-1'
  GITHUB_ORG: ${{ github.repository_owner }}

jobs:
  # ---------------------------------------------------------------------------
  # Step 0: Validate Prerequisites
  # ---------------------------------------------------------------------------
  validate:
    name: Validate Prerequisites
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ github.event.inputs.environment }}
      state_bucket: ${{ steps.set-bucket.outputs.bucket }}
      account_id: ${{ steps.set-bucket.outputs.account_id }}
    steps:
      - name: Validate AWS Credentials
        run: |
          if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then
            echo "::error::AWS_ACCESS_KEY_ID secret not configured"
            exit 1
          fi
          if [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            echo "::error::AWS_SECRET_ACCESS_KEY secret not configured"
            exit 1
          fi
          if [ -z "${{ secrets.AWS_SESSION_TOKEN }}" ]; then
            echo "::warning::AWS_SESSION_TOKEN not configured (required for AWS Academy)"
          fi
          echo "✓ AWS credentials configured"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          # AWS_SESSION_TOKEN is optional (only required for AWS Academy)
          # If not set, it will be empty and the action will ignore it
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS Account ID and Set Bucket Name
        id: set-bucket
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          STATE_BUCKET="fiap-tech-challenge-tf-state-${ACCOUNT_ID}"
          echo "account_id=${ACCOUNT_ID}" >> $GITHUB_OUTPUT
          echo "bucket=${STATE_BUCKET}" >> $GITHUB_OUTPUT
          echo "STATE_BUCKET=${STATE_BUCKET}" >> $GITHUB_ENV
          echo "AWS Account ID: ${ACCOUNT_ID}"
          echo "State Bucket: ${STATE_BUCKET}"

      - name: Check S3 Backend Exists
        run: |
          if ! aws s3api head-bucket --bucket "${STATE_BUCKET}" 2>/dev/null; then
            echo "::error::Terraform state bucket ${STATE_BUCKET} does not exist. Run bootstrap first!"
            exit 1
          fi
          echo "✓ Terraform state bucket exists: ${STATE_BUCKET}"

      - name: Check DynamoDB Lock Table
        run: |
          if ! aws dynamodb describe-table --table-name fiap-terraform-locks --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "::error::DynamoDB lock table does not exist. Run bootstrap first!"
            exit 1
          fi
          echo "✓ DynamoDB lock table exists"

      - name: Summary
        run: |
          echo "## Prerequisites Validated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AWS Account ID:** \`${{ steps.set-bucket.outputs.account_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **S3 Backend:** \`${STATE_BUCKET}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **DynamoDB Lock:** \`fiap-terraform-locks\`" >> $GITHUB_STEP_SUMMARY
          echo "- **AWS Region:** ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY

  # ---------------------------------------------------------------------------
  # Step 1a: Deploy EKS Cluster (Phase 1 - VPC, EKS only)
  # ---------------------------------------------------------------------------
  deploy-eks-cluster:
    name: "1a. Deploy EKS Cluster (Phase 1)"
    runs-on: ubuntu-latest
    needs: validate
    if: ${{ github.event.inputs.skip_eks != 'true' }}
    steps:
      - name: Trigger kubernetes-core-infra workflow (Phase 1)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: 'kubernetes-core-infra',
              workflow_id: 'terraform.yml',
              ref: '${{ github.event.inputs.environment == 'production' && 'main' || 'develop' }}',
              inputs: {
                environment: '${{ github.event.inputs.environment }}',
                action: 'apply'
              }
            });
            console.log('Triggered kubernetes-core-infra deployment (Phase 1)');

      - name: Wait for EKS cluster deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
            const dispatchTime = new Date().toISOString();
            const maxAttempts = 120;
            let attempts = 0;

            await delay(15000); // Wait for run to be created

            while (attempts < maxAttempts) {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: 'kubernetes-core-infra',
                workflow_id: 'terraform.yml',
                created: `>=${dispatchTime.split('T')[0]}`,
                per_page: 5
              });

              const latestRun = runs.data.workflow_runs.find(r => r.created_at >= dispatchTime);
              if (!latestRun) {
                console.log(`Waiting for run to appear (attempt ${attempts + 1})...`);
                attempts++;
                await delay(15000);
                continue;
              }

              console.log(`Run #${latestRun.id} status: ${latestRun.status}, conclusion: ${latestRun.conclusion}`);

              if (latestRun.status === 'completed') {
                if (latestRun.conclusion === 'success') {
                  console.log('EKS cluster deployment completed successfully (Phase 1)');
                  return;
                } else {
                  throw new Error(`EKS cluster deployment failed: ${latestRun.conclusion}`);
                }
              }

              attempts++;
              await delay(30000);
            }

            throw new Error('EKS cluster deployment timed out');

      - name: Summary
        run: |
          echo "## EKS Cluster Deployed (Phase 1)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** Success" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Next:** Deploy K8s Addons (Phase 2)" >> $GITHUB_STEP_SUMMARY

  # ---------------------------------------------------------------------------
  # Step 1b: Deploy Kubernetes Addons (Phase 2 - Namespaces, Helm releases)
  # ---------------------------------------------------------------------------
  deploy-eks-addons:
    name: "1b. Deploy K8s Addons (Phase 2)"
    runs-on: ubuntu-latest
    needs: [validate, deploy-eks-cluster]
    if: |
      always() &&
      needs.validate.result == 'success' &&
      (needs.deploy-eks-cluster.result == 'success' || needs.deploy-eks-cluster.result == 'skipped') &&
      github.event.inputs.skip_addons != 'true'
    steps:
      - name: Trigger kubernetes-addons workflow (Phase 2)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: 'kubernetes-addons',
              workflow_id: 'terraform.yml',
              ref: '${{ github.event.inputs.environment == 'production' && 'main' || 'develop' }}',
              inputs: {
                environment: '${{ github.event.inputs.environment }}',
                action: 'apply'
              }
            });
            console.log('Triggered kubernetes-addons deployment (Phase 2)');

      - name: Wait for K8s addons deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
            const dispatchTime = new Date().toISOString();
            const maxAttempts = 60;
            let attempts = 0;

            await delay(15000);

            while (attempts < maxAttempts) {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: 'kubernetes-addons',
                workflow_id: 'terraform.yml',
                created: `>=${dispatchTime.split('T')[0]}`,
                per_page: 5
              });

              const latestRun = runs.data.workflow_runs.find(r => r.created_at >= dispatchTime);
              if (!latestRun) {
                console.log(`Waiting for run to appear (attempt ${attempts + 1})...`);
                attempts++;
                await delay(15000);
                continue;
              }

              console.log(`Run #${latestRun.id} status: ${latestRun.status}, conclusion: ${latestRun.conclusion}`);

              if (latestRun.status === 'completed') {
                if (latestRun.conclusion === 'success') {
                  console.log('K8s addons deployment completed successfully (Phase 2)');
                  return;
                } else {
                  throw new Error(`K8s addons deployment failed: ${latestRun.conclusion}`);
                }
              }

              attempts++;
              await delay(30000);
            }

            throw new Error('K8s addons deployment timed out');

      - name: Summary
        run: |
          echo "## K8s Addons Deployed (Phase 2)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** Success" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Installed:** Namespaces, AWS LB Controller, Metrics Server" >> $GITHUB_STEP_SUMMARY

  # ---------------------------------------------------------------------------
  # Step 2: Deploy Database Infrastructure (RDS)
  # ---------------------------------------------------------------------------
  deploy-database:
    name: "2. Deploy Database Infrastructure"
    runs-on: ubuntu-latest
    needs: [validate, deploy-eks-cluster, deploy-eks-addons]
    if: |
      always() &&
      needs.validate.result == 'success' &&
      (needs.deploy-eks-cluster.result == 'success' || needs.deploy-eks-cluster.result == 'skipped') &&
      (needs.deploy-eks-addons.result == 'success' || needs.deploy-eks-addons.result == 'skipped') &&
      github.event.inputs.skip_database != 'true'
    steps:
      - name: Trigger database-managed-infra workflow
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: 'database-managed-infra',
              workflow_id: 'terraform.yml',
              ref: '${{ github.event.inputs.environment == 'production' && 'main' || 'develop' }}',
              inputs: {
                environment: '${{ github.event.inputs.environment }}',
                action: 'apply'
              }
            });
            console.log('Triggered database-managed-infra deployment');

      - name: Wait for Database deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
            const dispatchTime = new Date().toISOString();
            const maxAttempts = 40;
            let attempts = 0;

            await delay(15000);

            while (attempts < maxAttempts) {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: 'database-managed-infra',
                workflow_id: 'terraform.yml',
                created: `>=${dispatchTime.split('T')[0]}`,
                per_page: 5
              });

              const latestRun = runs.data.workflow_runs.find(r => r.created_at >= dispatchTime);
              if (!latestRun) {
                console.log(`Waiting for run to appear (attempt ${attempts + 1})...`);
                attempts++;
                await delay(15000);
                continue;
              }

              console.log(`Run #${latestRun.id} status: ${latestRun.status}, conclusion: ${latestRun.conclusion}`);

              if (latestRun.status === 'completed') {
                if (latestRun.conclusion === 'success') {
                  console.log('Database deployment completed successfully');
                  return;
                } else {
                  throw new Error(`Database deployment failed: ${latestRun.conclusion}`);
                }
              }

              attempts++;
              await delay(30000);
            }

            throw new Error('Database deployment timed out');

      - name: Summary
        run: |
          echo "## Database Infrastructure Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** Success" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY

  # ---------------------------------------------------------------------------
  # Step 2.5: Deploy Messaging Infrastructure (SQS, EventBridge)
  # ---------------------------------------------------------------------------
  deploy-messaging:
    name: "2.5. Deploy Messaging Infrastructure"
    runs-on: ubuntu-latest
    needs: [validate, deploy-eks-cluster, deploy-eks-addons, deploy-database]
    if: |
      always() &&
      needs.validate.result == 'success' &&
      (needs.deploy-eks-cluster.result == 'success' || needs.deploy-eks-cluster.result == 'skipped') &&
      (needs.deploy-eks-addons.result == 'success' || needs.deploy-eks-addons.result == 'skipped') &&
      (needs.deploy-database.result == 'success' || needs.deploy-database.result == 'skipped') &&
      github.event.inputs.skip_messaging != 'true'
    steps:
      - name: Trigger messaging-infra workflow
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: 'messaging-infra',
              workflow_id: 'terraform.yml',
              ref: '${{ github.event.inputs.environment == 'production' && 'main' || 'develop' }}',
              inputs: {
                environment: '${{ github.event.inputs.environment }}',
                action: 'apply'
              }
            });
            console.log('Triggered messaging-infra deployment');

      - name: Wait for Messaging deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
            const dispatchTime = new Date().toISOString();
            const maxAttempts = 20;
            let attempts = 0;

            await delay(15000);

            while (attempts < maxAttempts) {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: 'messaging-infra',
                workflow_id: 'terraform.yml',
                created: `>=${dispatchTime.split('T')[0]}`,
                per_page: 5
              });

              const latestRun = runs.data.workflow_runs.find(r => r.created_at >= dispatchTime);
              if (!latestRun) {
                console.log(`Waiting for run to appear (attempt ${attempts + 1})...`);
                attempts++;
                await delay(15000);
                continue;
              }

              console.log(`Run #${latestRun.id} status: ${latestRun.status}, conclusion: ${latestRun.conclusion}`);

              if (latestRun.status === 'completed') {
                if (latestRun.conclusion === 'success') {
                  console.log('Messaging infrastructure deployment completed successfully');
                  return;
                } else {
                  throw new Error(`Messaging infrastructure deployment failed: ${latestRun.conclusion}`);
                }
              }

              attempts++;
              await delay(30000);
            }

            throw new Error('Messaging infrastructure deployment timed out');

      - name: Summary
        run: |
          echo "## Messaging Infrastructure Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** Success" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Components:** SQS Queues, EventBridge" >> $GITHUB_STEP_SUMMARY

  # ---------------------------------------------------------------------------
  # Step 3: Deploy Lambda Functions
  # ---------------------------------------------------------------------------
  deploy-lambda:
    name: "3. Deploy Lambda Functions"
    runs-on: ubuntu-latest
    needs: [validate, deploy-eks-cluster, deploy-eks-addons, deploy-database, deploy-messaging]
    if: |
      always() &&
      needs.validate.result == 'success' &&
      (needs.deploy-eks-cluster.result == 'success' || needs.deploy-eks-cluster.result == 'skipped') &&
      (needs.deploy-eks-addons.result == 'success' || needs.deploy-eks-addons.result == 'skipped') &&
      (needs.deploy-database.result == 'success' || needs.deploy-database.result == 'skipped') &&
      (needs.deploy-messaging.result == 'success' || needs.deploy-messaging.result == 'skipped') &&
      github.event.inputs.skip_lambda != 'true'
    steps:
      - name: Trigger lambda-api-handler workflow
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: 'lambda-api-handler',
              workflow_id: 'deploy.yml',
              ref: '${{ github.event.inputs.environment == 'production' && 'main' || 'develop' }}',
              inputs: {
                environment: '${{ github.event.inputs.environment }}',
                action: 'deploy'
              }
            });
            console.log('Triggered lambda-api-handler deployment');

      - name: Wait for Lambda deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
            const dispatchTime = new Date().toISOString();
            const maxAttempts = 20;
            let attempts = 0;

            await delay(15000);

            while (attempts < maxAttempts) {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: 'lambda-api-handler',
                workflow_id: 'deploy.yml',
                created: `>=${dispatchTime.split('T')[0]}`,
                per_page: 5
              });

              const latestRun = runs.data.workflow_runs.find(r => r.created_at >= dispatchTime);
              if (!latestRun) {
                console.log(`Waiting for run to appear (attempt ${attempts + 1})...`);
                attempts++;
                await delay(15000);
                continue;
              }

              console.log(`Run #${latestRun.id} status: ${latestRun.status}, conclusion: ${latestRun.conclusion}`);

              if (latestRun.status === 'completed') {
                if (latestRun.conclusion === 'success') {
                  console.log('Lambda deployment completed successfully');
                  return;
                } else {
                  throw new Error(`Lambda deployment failed: ${latestRun.conclusion}`);
                }
              }

              attempts++;
              await delay(30000);
            }

            throw new Error('Lambda deployment timed out');

      - name: Summary
        run: |
          echo "## Lambda Functions Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** Success" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY

  # ---------------------------------------------------------------------------
  # Step 4: Deploy Phase 4 Microservices (os-service, billing-service, execution-service)
  # ---------------------------------------------------------------------------
  deploy-microservices:
    name: "4. Deploy Phase 4 Microservices"
    runs-on: ubuntu-latest
    needs: [validate, deploy-eks-cluster, deploy-eks-addons, deploy-database, deploy-messaging, deploy-lambda]
    if: |
      always() &&
      needs.validate.result == 'success' &&
      (needs.deploy-eks-cluster.result == 'success' || needs.deploy-eks-cluster.result == 'skipped') &&
      (needs.deploy-eks-addons.result == 'success' || needs.deploy-eks-addons.result == 'skipped') &&
      (needs.deploy-database.result == 'success' || needs.deploy-database.result == 'skipped') &&
      (needs.deploy-messaging.result == 'success' || needs.deploy-messaging.result == 'skipped') &&
      (needs.deploy-lambda.result == 'success' || needs.deploy-lambda.result == 'skipped') &&
      github.event.inputs.skip_app != 'true'
    env:
      NAMESPACE: ftc-app-${{ github.event.inputs.environment }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name fiap-tech-challenge-eks-${{ github.event.inputs.environment }}

      - name: Create ECR Repositories
        run: |
          for repo in os-service billing-service execution-service; do
            if ! aws ecr describe-repositories --repository-names "$repo" --region ${{ env.AWS_REGION }} 2>/dev/null; then
              aws ecr create-repository \
                --repository-name "$repo" \
                --image-scanning-configuration scanOnPush=true \
                --encryption-configuration encryptionType=AES256 \
                --region ${{ env.AWS_REGION }}
              echo "Created ECR repo: $repo"
            else
              echo "ECR repo exists: $repo"
            fi
          done

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Checkout os-service
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/os-service
          ref: ${{ github.event.inputs.environment == 'production' && 'main' || 'develop' }}
          token: ${{ secrets.GH_PAT }}
          path: os-service

      - name: Checkout billing-service
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/billing-service
          ref: ${{ github.event.inputs.environment == 'production' && 'main' || 'develop' }}
          token: ${{ secrets.GH_PAT }}
          path: billing-service

      - name: Checkout execution-service
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/execution-service
          ref: ${{ github.event.inputs.environment == 'production' && 'main' || 'develop' }}
          token: ${{ secrets.GH_PAT }}
          path: execution-service

      - name: Build and Push Docker Images
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ENV_TAG: ${{ github.event.inputs.environment == 'production' && 'prod' || 'dev' }}
        run: |
          for service in os-service billing-service execution-service; do
            echo "=== Building $service ==="
            cd $GITHUB_WORKSPACE/$service

            IMAGE_TAG="${ENV_TAG}-$(git rev-parse --short HEAD)"

            docker build --platform linux/amd64 \
              -t $ECR_REGISTRY/$service:$IMAGE_TAG \
              -t $ECR_REGISTRY/$service:${ENV_TAG}-latest \
              -t $ECR_REGISTRY/$service:latest \
              .

            docker push $ECR_REGISTRY/$service:$IMAGE_TAG
            docker push $ECR_REGISTRY/$service:${ENV_TAG}-latest
            docker push $ECR_REGISTRY/$service:latest

            echo "Pushed $service:$IMAGE_TAG"
          done

      - name: Create os-service-secrets from AWS Secrets Manager
        continue-on-error: true
        run: |
          SECRET_NAME="fiap-tech-challenge/${{ github.event.inputs.environment }}/database/credentials"
          SECRET_VALUE=$(aws secretsmanager get-secret-value \
            --secret-id "$SECRET_NAME" \
            --region ${{ env.AWS_REGION }} \
            --query SecretString \
            --output text 2>/dev/null || echo "")

          if [ -n "$SECRET_VALUE" ]; then
            DB_URL=$(echo "$SECRET_VALUE" | jq -r '.DATABASE_URL // empty')
            if [ -z "$DB_URL" ]; then
              HOST=$(echo "$SECRET_VALUE" | jq -r '.host // empty')
              PORT=$(echo "$SECRET_VALUE" | jq -r '.port // "5432"')
              DBNAME=$(echo "$SECRET_VALUE" | jq -r '.dbname // empty')
              USER=$(echo "$SECRET_VALUE" | jq -r '.username // empty')
              PASS=$(echo "$SECRET_VALUE" | jq -r '.password // empty')
              DB_URL="postgresql://${USER}:${PASS}@${HOST}:${PORT}/${DBNAME}?schema=public"
            fi
            kubectl create secret generic os-service-secrets -n ${{ env.NAMESPACE }} \
              --from-literal=DATABASE_URL="$DB_URL" \
              --dry-run=client -o yaml | kubectl apply -f -
            echo "os-service-secrets created"
          else
            echo "::warning::Could not fetch database credentials from Secrets Manager"
          fi

      - name: Update AWS Credentials in Kubernetes
        run: |
          for service in os-service billing-service execution-service; do
            kubectl create secret generic ${service}-aws-creds -n ${{ env.NAMESPACE }} \
              --from-literal=AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }} \
              --from-literal=AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }} \
              --from-literal=AWS_SESSION_TOKEN=${{ secrets.AWS_SESSION_TOKEN }} \
              --from-literal=AWS_REGION=${{ env.AWS_REGION }} \
              --dry-run=client -o yaml | kubectl apply -f -
          done

      - name: Run Database Migrations (os-service)
        continue-on-error: true
        run: |
          cd $GITHUB_WORKSPACE/os-service
          if [ -f k8s/migration-job.yaml ]; then
            kubectl delete job os-service-migration -n ${{ env.NAMESPACE }} --ignore-not-found=true
            kubectl apply -f k8s/migration-job.yaml -n ${{ env.NAMESPACE }}
            kubectl wait --for=condition=complete --timeout=300s job/os-service-migration -n ${{ env.NAMESPACE }} || {
              echo "Migration job logs:"
              kubectl logs -n ${{ env.NAMESPACE }} job/os-service-migration --tail=20
            }
          fi

      - name: Deploy Microservices to EKS
        run: |
          OVERLAY="${{ github.event.inputs.environment }}"

          echo "=== Deploying os-service ==="
          cd $GITHUB_WORKSPACE/os-service
          kubectl apply -k k8s/overlays/$OVERLAY

          echo "=== Deploying billing-service ==="
          cd $GITHUB_WORKSPACE/billing-service
          kubectl apply -k k8s/overlays/$OVERLAY

          echo "=== Deploying execution-service ==="
          cd $GITHUB_WORKSPACE/execution-service
          kubectl apply -k k8s/overlays/$OVERLAY || echo "execution-service deploy skipped (may need MongoDB)"

      - name: Wait for Deployments
        run: |
          # billing-service and execution-service development overlays use namePrefix: dev-
          if [ "${{ github.event.inputs.environment }}" == "development" ]; then
            PREFIX="dev-"
          else
            PREFIX=""
          fi

          echo "Waiting for os-service..."
          kubectl rollout status deployment/os-service -n ${{ env.NAMESPACE }} --timeout=5m || true

          echo "Waiting for ${PREFIX}billing-service..."
          kubectl rollout status deployment/${PREFIX}billing-service -n ${{ env.NAMESPACE }} --timeout=5m || true

          echo "Waiting for ${PREFIX}execution-service..."
          kubectl rollout status deployment/${PREFIX}execution-service -n ${{ env.NAMESPACE }} --timeout=5m || true

      - name: Verify Deployment
        run: |
          echo "=== Pods ==="
          kubectl get pods -n ${{ env.NAMESPACE }}
          echo ""
          echo "=== Services ==="
          kubectl get svc -n ${{ env.NAMESPACE }}
          echo ""
          echo "=== Ingress ==="
          kubectl get ingress -n ${{ env.NAMESPACE }}

      - name: Summary
        run: |
          echo "## Phase 4 Microservices Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** Success" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Services:** os-service, billing-service, execution-service" >> $GITHUB_STEP_SUMMARY

  # ---------------------------------------------------------------------------
  # Final Summary
  # ---------------------------------------------------------------------------
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [validate, deploy-eks-cluster, deploy-eks-addons, deploy-database, deploy-messaging, deploy-lambda, deploy-microservices]
    if: always()
    steps:
      - name: Generate Summary
        run: |
          echo "# Full Infrastructure Deployment Summary (Phase 4)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Environment: ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Prerequisites | ${{ needs.validate.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| EKS Cluster (Phase 1) | ${{ needs.deploy-eks-cluster.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| K8s Addons (Phase 2) | ${{ needs.deploy-eks-addons.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Database (RDS) | ${{ needs.deploy-database.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Messaging (SQS/EventBridge) | ${{ needs.deploy-messaging.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Lambda Functions | ${{ needs.deploy-lambda.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Microservices (OS, Billing, Execution) | ${{ needs.deploy-microservices.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Configure kubectl: \`aws eks update-kubeconfig --region us-east-1 --name fiap-tech-challenge-eks-${{ github.event.inputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "2. Check pods: \`kubectl get pods -n ftc-app-${{ github.event.inputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "3. Get ALB URL: \`kubectl get ingress -n ftc-app-${{ github.event.inputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "4. Get API Gateway URL from Lambda deployment output" >> $GITHUB_STEP_SUMMARY
